## 每日一题 - 264. 丑数 II

### 信息卡片

- 时间：2020-11-12
- 题目链接：https://leetcode-cn.com/problems/ugly-number-ii/
- tag：``
- 难度：中等

### 题目描述

```
编写一个程序，找出第 n 个丑数。

丑数就是质因数只包含 2, 3, 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
 
```

### 参考答案


####  暴力法：

依次遍历是否是丑数。

```
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        nums = 1
        count = 1
        while count < n:
            nums +=1
            num = nums
            for i in [2,3,5]:
                while num % i == 0:
                    num = num // i
            if num == 1:
                count +=1
        return nums

```

当然这样会超时，那接下来看看应该怎么改进。
 
####  动态规划：

之所以第一种方法会出现超时问题，是因为对于每个数，都是从头开始不断除以这3个数，这个过程中重复做了很多一样的计算。
例如：6是丑数，那么对于12，其是由6x2得到，那么我们可以借助6的丑数，只要一步计算即可知道12是丑数。

因此我们可以将除改成乘，即所有的丑数有数由2,3,5相乘生成的，因此1,2,3,4,5,6,8,9....丑数序列可以看成
1,1x2,1x3,2x2,1x5,2x3,2x2x2,3x3...

我们可以把丑数分成三组，用丑数序列分别乘 2, 3, 5 。

乘 2: 1×2, 2×2, 3×2, 4×2, 5×2, 6×2, 8×2,9×2,…
乘 3: 1×3, 2×3, 3×3, 4×3, 5×3, 6×3, 8×3,9×3,…
乘 5: 1×5, 2×5, 3×5, 4×5, 5×5, 6×5, 8×5,9×5,…

我们要做的就是将这三部分合并成递增的序列，即可得到所有的丑数序列。

这里使用i2,i3,i5三个指针，做用户记录上一个状态下，由2,3,5乘积后的数字。

```
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        Ugly = [1]
        i2,i3,i5  = 0,0,0  #指针状态
        for i in range(n):
            ugly = min(Ugly[i2]*2,Ugly[i3]*3,Ugly[i5]*5)
            Ugly.append(ugly)
			## 更新 i2,i3,i5 指针状态
            if ugly == Ugly[i2]*2:
                i2 += 1
            if ugly == Ugly[i3]*3:
                i3 += 1
            if ugly == Ugly[i5]*5:
                i5 += 1
        return Ugly[n-1]
```


### 其他优秀解答

```
暂无
```



