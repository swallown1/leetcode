## 每日一题 - 1005. K 次取反后最大化的数组和

### 信息卡片

- 时间：2020-03-18
- 题目链接：https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/
- tag：`贪心算法` 
- 难度：简单

### 题目描述

```

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。

 

示例 1：

输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
示例 2：

输入：A = [3,-1,0,2], K = 3
输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
示例 3：

输入：A = [2,-3,-1,5,-4], K = 2
输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
 

提示：

1 <= A.length <= 10000
1 <= K <= 10000
-100 <= A[i] <= 100

```

### 参考答案

#### 按照过程

参考代码

### 贪心算法

解题思路：

采用贪心算法的思路其实就是每次转换的数是最小的数才是最好的，这样的情况才能保证和是最大的。（提示 不要看示例中的解释，这里不需要考虑索引的问题，因为问的是最大的和，我刚开始也被误导了。）

算法流程：

进行K次循环，每次进行排序，将最小的值进行取反就行。


```python
/*
 * @lc app=leetcode id=1005 lang=python
 *
 * [1005]  K 次取反后最大化的数组和
 */

class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        for i in range(K):
            A.sort()
            A[0] = -A[0]
        return sum(A)

        
```

时间复杂度：O(nlogn)，其中 排序的时间复杂度是O(nlogn)，循环K次后 时间复杂度为O(K*NlogN)
 因此时间复杂度为 O(nlogn)


### 其他优秀解答
```
暂无
```



