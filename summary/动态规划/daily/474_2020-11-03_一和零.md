## 每日一题 - 474.  一和零

### 信息卡片

- 时间：2020-12-22
- 题目链接：https://leetcode-cn.com/problems/ones-and-zeroes/
- tag：`动态规划`
- 难度：中等

### 题目描述

```
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

 

示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
示例 2：

输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。

```

### 参考答案

**题意理解：**


#### 动态规划

这道题的状态数组采用二维数组的方式，定义是 对于n个0和m个1最多能容纳多少子串。

对于每一个子字符，我们可以先计算他的0和1 的个数，状态转移方程可以得到

dp[i][j] = max(dp[i][j],dp[i-count_0][j-count_1]+1)

再看看遍历的两个状态，

```
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0]*(n+1) for _ in range(m+1)]

        for k in strs:
            count_0 = k.count("0")
            count_1 = k.count("1")
            for i in range(m,count_0-1,-1): #0的个数
                for j in range(n,count_1-1,-1):
                    dp[i][j] = max(dp[i][j],dp[i-count_0][j-count_1]+1)    
        return dp[-1][-1]
```

### 其他优秀解答

```
暂无
```



