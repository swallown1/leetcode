## 每日一题 - 198. 打家劫舍

### 信息卡片

- 时间：2020-12-13
- 题目链接：https://leetcode-cn.com/problems/house-robber/
- tag：`动态规划`
- 难度：简单


### 题目描述

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
 
```

### 参考答案

### 动态规划

这道题采用的是动态规划的思想

**分析：**

从左到右走过这一排房子，在每间房子前都有两种选择：抢或者不抢。

如果你抢了这间房子，那么你肯定不能抢相邻的下一间房子了，只能从下下间房子开始做选择。

如果你不抢这间房子，那么你可以走到下一间房子前，继续做选择。

当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（base case）。


因此状态转移就是：

dp[n] = max(dp[n-1],dp[n-2]+nums[n])

但这里有个问题就是n-2在一开始的时候是个问题，因此这里有一个技巧就是从后往前偷，这样就比较简单了。

因此状态转移方程就可以是：

dp[n] = max(dp[n+1],dp[n+2]+nums[n])

于是有了下面

```
class Solution:
    def rob(self, nums: List[int]) -> int:
        dp = [0 for _ in range(len(nums)+2)]
        for n in range(len(nums)-1,-1,-1):
            dp[n] = max(dp[n+1],dp[n+2]+nums[n])
        return dp[0]
```

**优化：**

因为只需要前面两次子状态的结果，因此只需要两个变量

```
class Solution:
    def rob(self, nums: List[int]) -> int:
        dp_1 = dp_2 = dp =0
        for n in range(len(nums)-1,-1,-1):
            dp = max(dp_1,dp_2+nums[n])
            dp_2 = dp_1
            dp_1 = dp
        return dp
```

### 其他优秀解答

```
暂无
```
 