1. 两数之和：
	给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那两个整数，并返回它们的数组下标。
	你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
	你可以按任意顺序返回答案。
	思路：使用set的方式，键值对是  索引和值。通过 target-val 找到索引。
	 
2. 两数相加
	给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
	请你将两个数相加，并以相同形式返回一个表示和的链表。
	你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
	思路：注意末位置相加大于10，要记录大于10的结果给下一位相加。注意遍历结束要查看p的状态
```
class Solution:
	def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
		head = ListNode(0)
		node = head
		p = 0
		while l1 or l2:
			x = l1.val if l1 else 0
			y = l2.val if l2 else 0
			node.next= ListNode((x+y+p)%10) 
			p = (x+y+p)//10
			if l1:
				l1 = l1.next
			if l2:
				l2 = l2.next
			node = node.next
		if p != 0 :
			node.next = ListNode(1)
		return head.next
```

3. 无重复字符的最长子串
	给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
	思路：使用一个list存储无重复子串，当出现重复的时候，弹出list的第一位。
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        res,end,mask= 0,0,[] 
        for start in range(len(s)):
            if start !=0:
                mask.remove(s[start-1])
            while end < len(s) and s[end] not in mask:
                mask.append(s[end])
                end +=1
            res = max(res,end-start)
        return res
```

5. 最长回文子串
	给你一个字符串 s，找到 s 中最长的回文子串。
	思路：中心查找法，通过中心往两边扩。要注意回文子串存在奇偶个数问题
```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        ans = ""
        for i in range(len(s)):
            odd = self._center(s,i,i)
            even = self._center(s,i,i+1)
            if len(odd)>len(even) and len(odd) > len(ans):
                    ans = odd
            elif len(even) > len(ans):
                    ans = even
        return ans

    def _center(self,s,left,right):
        while left >=0 and right < len(s) and s[left] == s[right] :
            left -=1
            right +=1
        return s[left+1:right]
```

11. 盛最多水的容器
	给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，
	垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器
	可以容纳最多的水。
	思路：双指针法，决定最大容积的条件就是移动两端中最短的一个。
```
class Solution:
    def maxArea(self, height: List[int]) -> int:
        res = 0
        pre , end = 0 , len(height)-1
        while pre < end:
            tmp = min(height[pre],height[end])*(end-pre)
            res = max(tmp,res)
            if height[pre] < height[end]:
                pre +=1
            else:
                end -=1
        return res
```

15. 三数之和
	给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？
	请你找出所有和为 0 且不重复的三元组。
	思路：将nums进行排序，然后回溯所有情况，这里注意当nums[k]大于0时，不可能组成三元组。并且当
	k和k-1相等时，直接跳过。
```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        n = len(nums)
        if nums == None or n < 3:return ans
        nums.sort()
        for k in range(n-2):
            if nums[k]>0:break
            if k>0 and nums[k]==nums[k-1]:continue #如果和前一个数一样，跳过
            i,j=k+1,n-1
            while i<j:
                s = nums[k] + nums[i] + nums[j]
                if s > 0:
                    j -=1
                    while nums[j] == nums[j + 1] and i < j: j -= 1
                if s < 0:
                    i+=1
                    while nums[i] == nums[i - 1] and i < j: i += 1
                if s == 0:
                    ans.append([nums[k],nums[i],nums[j]])
                    i+=1
                    j-=1
                    while nums[i] == nums[i-1] and i<j: i+=1
                    while nums[j] == nums[j+1] and i<j: j-=1
        return ans
```

17. 电话号码的字母组合
	给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
	思路：类似这种排列组合的题，大多数采用回溯的思路。定义一个递归函数，每次调用相当于一个数字对应的所有字母。
```
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if digits == '':
            return []
        conversion={'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        res = []
        def backstrap(curr,nextdigits):
            if len(nextdigits) == 0:
                res.append(curr)
                return 
            for i in conversion[nextdigits[0]]:
                backstrap(curr+i,nextdigits[1:])     
        backstrap('',digits)
        return res
```

19. 删除链表的倒数第 N 个结点
	给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
	思路：采用双指针法，双指针之间的距离等于n，这样当右边的指针到尾部时，左指针指的就是倒数第n个
```
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        p1 =p2= head
        for _ in range(n):
            p2 = p2.next
        if not p2: return head.next
        while p2.next:
            p1 = p1.next
            p2 = p2.next
        p1.next = p1.next.next
        return head
```

20. 有效的括号
	给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：
	左括号必须用相同类型的右括号闭合;左括号必须以正确的顺序闭合。
	思路：采用栈的思路，当能匹配的时候，弹出，不匹配直接返回False。注意这里只需要匹配],},)即可。
```
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {")":"(","}":"{","]":"["}
        stack = []
        for i in s:
            if stack and i in dic:
                if stack[-1] == dic[i]:stack.pop()
                else: return False
            else: stack.append(i)
        return not stack
```

22. 括号生成
	数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
	思路：如果左括号数量不大于 n，我们可以放一个左括号。
	如果右括号数量小于左括号的数量，我们可以放一个右括号。
```
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def strack(S,left,right):
            if len(S) == 2*n: 
                res.append(''.join(S))
            if left < n:
                S.append('(')
                strack(S,left+1,right)
                S.pop()
            if right<left:
                S.append(')')
                strack(S,left,right+1)
                S.pop()
        strack([],0,0)
        return res
```

33. 搜索旋转排序数组
	升序排列的整数数组 nums 在预先未知的某个点上进行了旋转（例如， [0,1,2,4,5,6,7] 经旋转后可能变为 [4,5,6,7,0,1,2] ）。
	请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。																																																																														
	思路：二分法，旋转过的数组其实是存在两个子部分是单调的，因此需要先确定left到mid是否单调，在判定
	target所在范围，不断减小范围，找到目标值。
```
class Solution:
    def search(self, nums: List[int], target: int) -> int:
		if not nums:
			return -1
		left,right = 0,len(nums)-1
		while left < right:  # 结束条件 left == right
			mid = (left+right) // 2
			if nums[mid] < nums[left]: # 右部分有序，左部分有最小值
				if target <= nums[mid] or target >= nums[left]: #在左部分 ，right移动
					right = mid
				else:
					left = mid + 1
			elif nums[mid] > nums[left]: # 左部分有序，右部分有最小值
				if target <= nums[mid] and target >= nums[left]: #在左部分 ，right移动
					right = mid
				else:
					left = mid + 1
			else:
				if nums[left] != target: # 出现重复的情况
					left +=1
				else:
					return left  # 最左边与target相等
		return left if nums[left] == target else -1
```

34. 在排序数组中查找元素的第一个和最后一个位置
	给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
	如果数组中不存在目标值 target，返回 [-1, -1]。
	思路：通过二分法找到左边缘，在利用一遍二分法找到右边缘，因为这是单调递增的。
```
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left,right=0,len(nums)-1
        while left < right:
            mid = (left+right) // 2
            if nums[mid] >= target:
                right = mid
            else:
                left = mid +1
        if not nums or nums[left] != target:
            return [-1,-1]
        ans = left
        right = len(nums)-1
        while left < right:
            mid = (left+right+1) // 2
            if nums[mid] == target:
                left = mid
            else:
                right = mid-1
        return [ans,left]
```


39. 组合总和
	给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
	candidates 中的数字可以无限制重复被选取。
	思路:这道题就是回溯的思想，即通过递归函数，不断的进行组合，函数需要两个参数，当前组合的
	总和tmp以及当前组合的list。这道题需要注意一点就是不能出现重复组合。其实最简单的方式就是
	让list中是递增的排序，就是说新加入list的值要大于curr中最后一个，就不会出现重复情况了。
```
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        def  findout(tmp,curr):
            if tmp > target:
                return 
            if tmp == target:
                res.append(curr)
            for i in candidates:
                if not curr or curr[-1] <= i:
                    findout(tmp+i,curr+[i])
        findout(0,[])
        return res
```

46. 全排列
	给定一个 没有重复 数字的序列，返回其所有可能的全排列。
	思路：采用回溯法，进行递归组合，这里可以参考上一题的模板
```
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backstrack(curr):
            if len(curr) == len(nums):
                res.append(curr)
                return 
            for i in nums:
                if i in curr:
                    continue
                backstrack(curr+[i])
        backstrack([])
        return res
```

49. 字母异位词分组
	给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
	思路：这里关键的点是，将字符串转化成26*[0]的list，将这个作为字典的索引。
```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        tmp = collections.defaultdict(list)
        for l in strs:
            characters = [0]*26
            for c in l:
                characters[ord(c)-ord('a')] +=1
            tmp[tuple(characters)].append(l)
        return [*tmp.values()]
```

50. Pow(x, n)
	实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。
```
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x==0.0:return 0.0
        if n < 0:x,n = 1/x,-n
        res = 1
        while n:
            if n & 1: res *=x
            x *=x
            n >>= 1
        return res
```

53. 最大子序和
	给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。	
	思路：dp的思路，关键点在于，当前位置的最大值和前一个状态相关，因此只需要比较前一个状态tmp加上当前
	位置的数i和i比较即可。则状态转移方差为tmp = max(tmp+i,i)
```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        tmp = -2
        ans = nums[0]
        for i in nums:
            tmp = max(tmp+i,i)
            ans = max(tmp,ans)
        return ans
```

55. 跳跃游戏
	给定一个非负整数数组，你最初位于数组的第一个位置。
	数组中的每个元素代表你在该位置可以跳跃的最大长度。
	判断你是否能够到达最后一个位置。
	思路：这道题的思路是，设置一个最远距离k，如果遍历超过这个最远距离且未全部遍历完，表示
	当前不能到最后。如果知道遍历完，都没查过k，这表示可以到最后。
```
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        k = 0 
        for i in range(len(nums)):
            if i>k:return False
            k = max(k,i+nums[i])
        return True
```

56. 合并区间
	给出一个区间的集合，请合并所有重叠的区间。输入: intervals = [[1,3],[2,6],[8,10],[15,18]]; 输出: [[1,6],[8,10],[15,18]]
	思路：这道题是先把第一位排序，这样确定的第一位，只需要考虑第二个位置上数字在下一个区间的所在位置即可，
```
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key = lambda x :x[0])
        res = [intervals[0]]
        for item in intervals[1:]:
            if res[-1][1] >= item[0]: 
                if res[-1][1] < item[1]:
                    res[-1][1] = item[1]
            else:
                res.append(item)
        return res
```

57. 插入区间
	给你一个 无重叠的 ，按照区间起始端点排序的区间列表。
	在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
```
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        ans = []
        place = False
        left,right = newInterval[0],newInterval[1]
        for l,r in intervals:
            if r < left:
                ans.append([l,r])
            elif l > right:
                if not place:
                    ans.append([left,right])
                    place = True
                ans.append([l,r])
            else:
                left = min(left,l)
                right = max(right,r)
        if not place:
            ans.append([left,right])
        return ans

```

58. 最后一个单词的长度
	给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。
	单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
```
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        end = len(s) - 1
        while end >=0 and s[end] == ' ': end -=1
        if end < 0: return 0
        start = end
        while start >=0 and s[start] != ' ': start -=1
        return end - start
		
or return len(s.strip().split(' ')[-1])
```

[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

思路：主要k可能大于链表的长度，因此需要先遍历链表，然后去k取余
，然后将链表连城一个环，然后移动到分裂的位置，即可。

```
def rotateRight(self, head: ListNode, k: int) -> ListNode:
	if not head:return head
	num = 1
	p = head
	while p.next:
		p = p.next
		num +=1
	p.next = head
	k = k%num
	for _ in range(num - k):
		p = p.next 
	head = p.next
	p.next = None
	return head
```

62. 不同路径
	一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。	
	机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
	问总共有多少条不同的路径？
	思路：经典的动态规划吧，同过二维数组来保持自状态，状态转移方程为dp[i][j] = dp[i-1][j]+dp[i][j-1]
```
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        result = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]
        for i in range(1,m):
            for j in range(1,n):
                result[i][j] = result[i-1][j] + result[i][j-1]
        return result[-1][-1]
```

[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

	一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

	机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

	现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

```
if obstacleGrid == None or len(obstacleGrid) == 0 or obstacleGrid[0][0]==1: return 0;
	m = len(obstacleGrid)
	n = len(obstacleGrid[0]) 
	dp= [[0]*n for _ in range(m)]
	for i in range(m):
		if obstacleGrid[i][0]==0:
			dp[i][0] = 1;
	for j in range(n):
		if obstacleGrid[0][j]==0:
			dp[0][j] = 1;
	for i in range(1,m):
		for j in range(1,n):
			if obstacleGrid[i][j]==0:
				dp[i][j] = dp[i-1][j] + dp[i][j-1];
	return dp[m-1][n-1];
```
 


[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)
	
	给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
	
	思路：这道题其实和上一道同思路，主要是状态转移不同，这里要找到最小的子状态，状态转移方程：
	dp[i][j] +=min(dp[i-1][j]+dp[i][j-1])  不过还得注意一下初始值。
```
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i==0 and j==0 :
                    continue
                elif i == 0:
                    grid[i][j] += grid[0][j-1]
                elif j == 0:
                    grid[i][j] += grid[i-1][0]
                else:
                    grid[i][j] +=min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
```

[66. 加一](https://leetcode-cn.com/problems/plus-one/)

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
 
```
def plusOne(self, digits: List[int]) -> List[int]:
	for i in range(len(digits)-1,-1,-1):
		digits[i] +=1
		digits[i] %=10
		if digits[i] != 0: return digits
	return [1]+digits
```

[67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。

计算当前 xx 和 yy 的无进位相加结果：answer = x ^ y
计算当前 xx 和 yy 的进位：carry = (x & y) << 1
完成本次循环，更新 x = answer，y = carry 
```
def addBinary(self, a: str, b: str) -> str:
	a,b = int(a,2),int(b,2)
	while b:
		ans = a ^ b
		carry = (a & b) << 1
		a,b = ans,carry
		print(a,b)
	return bin(a)[2:]
```


71. 简化路径

```
def simplifyPath(self, path: str) -> str:
	stack = []
	path = path.split('/')

	for item in path:
		if item == '..':
			if stack:stack.pop()
		elif item and item !='.':
			stack.append(item)
	return '/'+'/'.join(stack)
```

72. 编辑距离
	给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
	你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符
	思路：定义一个二维数组，每个位置的含义是指如果第i和第j的元素不相同，则只需要继承前一个状态+1即可(即增加一个元素或减少一个元素)，
	如果相同，只需要继承第上和左的状态。注意二维数组要多一个维度
```
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m = len(word1)
        n = len(word2)
        if m*n == 0:
            return m+n
        D = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m+1):
            D[i][0] = i
        for i in range(n+1):
            D[0][i] = i
        for i in range(1,m+1):
            for j in range(1,n+1):
                left = D[i-1][j]+1
                right = D[i][j-1]+1
                down = D[i-1][j-1]
                if word1[i-1] != word2[j-1]:
                    down+=1
                D[i][j] = min(left,min(right,down))
        return D[i][j]
```

[74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。
 
思路：其实还是二分法，这里不过要对坐标进行转换。横坐标是  mid // col,钟作本是  mid - (mid//col)*col

```
def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
	if not matrix or not matrix[0]:
		return False
	row = len(matrix)
	col = len(matrix[0])
	left,right = 0, row*col-1
	while left <= right:
		totle = (right+left)//2
		mid = [totle//col,totle-(totle//col)*col]
		if matrix[mid[0]][mid[1]] == target:
			return True
		elif matrix[mid[0]][mid[1]] > target:
			right = mid[0]*col+mid[1]-1
		else:
			left = mid[0]*col+mid[1]+1
	return False
```


73. 矩阵置零
	给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。
```
def setZeroes(self, matrix: List[List[int]]) -> None:
	m,n = len(matrix),len(matrix[0])
	col,row = [],[]
	for i in range(m):
		for j in range(n):
			if matrix[i][j] == 0:
				if i not in row:row.append(i)
				if j not in col:col.append(j)
	for i in row:matrix[i] = [0]*n
	for j in col:
		for i in range(m):
			matrix[i][j] = 0
	return matrix
```

75. 颜色分类
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

思路：使用两个指针分别记录0和2的末尾位置，然后使用curr遍历，当遇见0和p1交换，当遇见2和p2交换。
```
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        p0,p2,curr = 0,len(nums)-1,0
        while curr<=p2:
            if nums[curr] == 0:
                nums[p0],nums[curr]=nums[curr],nums[p0]
                p0 +=1
                curr +=1
            elif nums[curr] == 2:
                nums[p2],nums[curr]=nums[curr],nums[p2]
                p2-=1
            else:curr +=1
        return nums
```

76. 最小覆盖子串
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

思路：这里采用字典存储，移动窗口则字典里面的计数减1,并且使用counter记录t是否全部在窗口内。
如果全部在记录找到最短窗口，并且缩小窗口。注意缩小窗口时，如果计数等于0，表示该字母在t中，此时counter需要+1
```
from collections import defaultdict
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        tdict = defaultdict(int)
        for i in range(len(t)):tdict[t[i]] +=1
        counter = len(t)
        minlen,ans,left,sdict = len(s)+1,"",0,defaultdict(int)
        for right in range(len(s)):
            if tdict[s[right]] > 0:
                counter -=1
            tdict[s[right]] -=1
            while counter == 0:  # 表明窗口内已经存在t
                if minlen > right - left +1:  # 找到最短的子串
                    minlen = right - left +1
                    ans = s[left:right+1]
                if tdict[s[left]] == 0: # 表示如果t中的字母被移除，counter从新添加
                    counter +=1
                tdict[s[left]] +=1   
                left +=1
        return ans
```

[77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

```
def combine(self, n: int, k: int) -> List[List[int]]:
	res = []
	def backtrack(tmp,idx = 1):
		if len(tmp) == k:
			res.append(tmp)
		for i in range(idx,n+1):
			backtrack(tmp+[i],i+1)
	backtrack([])
	return res
```

[78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

思路：这道题就是回溯的方法来做了。
```
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:  
        res = []
        def backtrak(tmp,k=0):
            res.append(tmp)
            for i in range(k,len(nums)):
                backtrak(tmp+[nums[i]],i+1)
        backtrak([])
        return res
```

79. 单词搜索

给定一个二维网格和一个单词，找出该单词是否存在于网格中。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

思路：回溯法，这里关键在于，先判断第i,j点是否等于word[k]，并且定义递归出口k==len(word)
其次对于点i,j可以递归的点是4个，但是只有满足该点在范围内且未被访问才可以递归。
因此还需要一个数组记录是否被遍历的标识。
```
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        rows = len(board)
        cols = len(board[0])
        idx = [[0]*cols for _ in range(rows)]
        x = [0,1,-1,0]
        y = [1,0,0,-1]
        def backtrap(r,c,k):
            if board[r][c] != word[k]:
                return False
            if k == len(word)-1:
                return True
            idx[r][c] = 1
            for i in range(4):
                xn = r + x[i]
                yn = c + y[i]
                if 0<=xn<rows and 0<=yn<cols and idx[xn][yn]!=1 and backtrap(xn,yn,k+1):
                    return True
            idx[r][c] = 0
            return False
        for i in range(rows):
            for j in range(cols):
                if backtrap(i,j,0):
                    return True
        return False
```

[80. 删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

给定一个增序排列数组 nums ，你需要在 原地 删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

```
def removeDuplicates(self, nums: List[int]) -> int:
	j,count = 1,1
	for i in range(1,len(nums)):
		if nums[i] == nums[i-1]:
			count +=1
		else: count = 1
		if count <=2:
			nums[j] = nums[i]
			j +=1
	return j
```

[81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

	假设按照升序排序的数组在预先未知的某个点上进行了旋转。
	( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。
	编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。
```
def search(self, nums: List[int], target: int) -> int: 
	if not nums:
		return False
	left,right = 0,len(nums)-1
	while left < right:  # 结束条件 left == right
		mid = (left+right) // 2
		if nums[mid] < nums[left]: # 右部分有序，左部分有最小值
			if target <= nums[mid] or target >= nums[left]: #在左部分 ，right移动
				right = mid
			else:
				left = mid + 1
		elif nums[mid] > nums[left]: # 左部分有序，右部分有最小值
			if target <= nums[mid] and target >= nums[left]: #在左部分 ，right移动
				right = mid
			else:
				left = mid + 1
		else:
			if nums[left] != target: # 出现重复的情况
				left +=1
			else:
				return True  # 最左边与target相等
	return True if nums[left] == target else False
```

[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。
思路：由于重复核能出现在开头，因此需要头指针；先查询curr和curr.next是否重复
如果重复则继续看有2个以上的重复

```
def deleteDuplicates(self, head: ListNode) -> ListNode:
	thead = ListNode('1')
	thead.next = head
	curr,pre = thead,None
	while curr:
		pre = curr
		curr = curr.next
		while curr and curr.next and curr.val == curr.next.val:
			t = curr.val
			curr = curr.next.next
			while curr and curr.val == t:
				curr = curr.next
		pre.next = curr
	return thead.next
```

[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

	给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
```
def deleteDuplicates(self, head: ListNode) -> ListNode:
	curr = head
	while curr and curr.next:
		if curr.val == curr.next.val:
			curr.next = curr.next.next
		else:
			curr = curr.next
	return head
```

84. 柱状图中最大的矩形
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
思路：这道题的思路比较新颖，主要想法是将height按照递增顺序放入栈中，一次计算最大面积。
需要注意heights要在前后加上两个0，这样保证了可以计算到整个范围。
```
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights = [0]+heights+[0]
        stack = []
        ans = 0
        for h in range(len(heights)):
            while stack and heights[h] < heights[stack[-1]]:
                tmp = stack.pop()
                ans = max(ans,(h-stack[-1]-1)*heights[tmp])
            stack.append(h)
        return ans
```

85. 最大矩形
给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
思路：这道题的思路就是基于上一题了，单调栈。
```
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if len(matrix) == 0 :return 0
        rows = len(matrix)
        cols = len(matrix[0])
        ans = 0
        heights = [0]*(cols+2)
        def area(heights):
            res = 0
            stack = []
            heights = [0] + heights +[0]
            for i in range(len(heights)):
                while stack and heights[stack[-1]] > heights[i]:
                    tmp = stack.pop()
                    res = max(res,(i-stack[-1]-1)*heights[tmp])
                stack.append(i)
            return res
        for r in range(rows):
            for c in range(cols):
                if matrix[r][c] == '0':
                    heights[c+1] = 0
                else:
                    heights[c+1] = heights[c+1]+1
            ans = max(ans,area(heights))
        return ans
```

[86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
你应当 保留 两个分区中每个节点的初始相对位置。

```
def partition(self, head: ListNode, x: int) -> ListNode:
	p = head
	low = ListNode(0)
	hight = ListNode(1)
	l,h = low,hight
	while p:
		if p.val < x:
			l.next = p
			l = l.next
		elif p.val >=x:
			h.next = p
			h = h.next
		p = p.next
	l.next = hight.next
	h.next = None
	return low.next
```

[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素

```
def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
	p1,p2 = m-1,n-1
	i = len(nums1)-1
	while p1 !=-1 and p2!=-1:
		if nums2[p2] > nums1[p1]:
			nums1[i] = nums2[p2]
			p2 -=1
		else:
			nums1[i] = nums1[p1]
			p1 -=1
		i -=1
	if p1 == -1: nums1[:p2+1] = nums2[:p2+1]
	return nums1
```

[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。

思路：由于子集不能重复，因此当nums[i]与前一个i-1相等时，直接跳过
```
def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
	res = []
	nums.sort()
	def backstrap(tmp,idx):
		res.append(tmp)
		for i in range(idx,len(nums)):
			if i > idx and nums[i] == nums[i-1]:
				continue
			backstrap(tmp+[nums[i]],i+1)
		return tmp
	backstrap([],0)
	return res
```
[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

```
def numDecodings(self, s: str) -> int:
	if not len(s) or s[0] == '0': return 0
	curr = 1
	pre = 1
	for i in range(2,len(s)+1):
		tmp = curr
		if s[i-1] == '0':
			if s[i-2] == '1' or s[i-2] == '2':
				curr = pre
			else: return 0;
		elif s[i-2]== '1' or (s[i-2]=='2' and '1'<=s[i-1]<='6'):
			curr = curr+pre
		pre = tmp
	return curr
```

94. 二叉树的中序遍历
给定一个二叉树的根节点 root ，返回它的 中序 遍历。
```
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        stack ,res =[], []
        curr = root
        while stack or curr:
            while curr:
                stack.append(curr)
                curr = curr.left
            curr = stack.pop()
            res.append(curr.val)
            curr = curr.right
        return res
```
后序遍历。
```
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []
        stack = [root]
        ans = []
        while stack and root:
            ans.append(root.val)
            if root.left:
                stack.append(root.left)
            if root.right:
                stack.append(root.right)
            root = stack.pop()
        return ans[::-1]
```

96. 不同的二叉搜索树
	给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
	思路：通过dp存储整数i组成的二叉搜索树dp[i]，状态转移为 dp[i]=sum(dp[j]*dp[i-j-1])
```
def numTrees(self, n: int) -> int:
	if n<=1: return 1;
	dp = [0]*(n+1)
	dp[0],dp[1] = 1,1
	for i in range(2,n+1):
		for j in range(i):
			dp[i] += (dp[j]*dp[i-j-1])
	return dp[-1]
```


98. 验证二叉搜索树
	给定一个二叉树，判断其是否是一个有效的二叉搜索树。
	假设一个二叉搜索树具有如下特征：
	节点的左子树只包含小于当前节点的数。
	节点的右子树只包含大于当前节点的数。
	所有左子树和右子树自身必须也是二叉搜索树。
	思路：二叉搜索树的中序遍历，只需要保证当前值都大于前一个值，则为二叉搜索树。不知道为啥用递归就不对。
```
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack,prevalue = [],float('-inf')
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            node = stack.pop()
            if node.val <= prevalue:
                return False
            prevalue = node.val
            root = node.right
        return True
```

99. 恢复二叉搜索树
	给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
	思路：利用中序遍历递增的特点，遍历寻找两个错位置的点，通过前一个值大于当前值找出
	错误位置，通过两个指针找出，然后交换即可

```
def recoverTree(self, root: TreeNode) -> None:
	nodes = []
	def dfs(root):
		if not root:return 
		dfs(root.left)
		nodes.append(root)
		dfs(root.right)
	dfs(root)
	x,y = None,None
	pre = nodes[0]
	for i in range(1,len(nodes)):
		if nodes[i].val < pre.val:
			y = nodes[i]
			if not x:x = pre
		pre = nodes[i]
	if x and y: x.val,y.val = y.val,x.val
```

100. 相同的树
	给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
	如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
	思路：对于根节点，如果都为空节点是对称的，如果有一个是空则不对称，值不等不对称
	然后就是对比两数的左右子树了。
```
def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
	if not p and not q:
		return True
	elif not p or not q:
		return False
	elif p.val != q.val:
		return False
	return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
```

101. 对称二叉树
	给定一个二叉树，检查它是否是镜像对称的。
```
def isSymmetric(self, root: TreeNode) -> bool:
	if not root: return True
	def dfs(left,right):
		if not (left or right):
			return True
		elif not (left and right):
			return False
		elif left.val != right.val:
			return False
		return dfs(left.left,right.right) and dfs(left.right,right.left)
	return dfs(root.left,root.right)
```

102. 二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
思路：使用队列，并且每次一次弹出当前队列里面的所有节点。
```
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:return []
        res = []
        queue=[root]
        while queue:
            tmp =[]
            for _ in range(len(queue)):
                node = queue.pop(0)
                tmp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(tmp)
        return res
```

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

思路：如果是偶数次的话，tmp的插入从左插入，否则从有插入，奇 偶通过res中的长度来判断。

```
def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
	if not root: return []
	res,queue=[],[root]
	while queue:
		tmp = collections.deque()
		for _ in range(len(queue)):
			root = queue.pop(0)
			if len(res) % 2: tmp.appendleft(root.val)
			else:tmp.append(root.val)
			if root.left:queue.append(root.left)
			if root.right:queue.append(root.right)
		res.append(list(tmp))
	return res
```

107. 二叉树的层序遍历 II
	给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
	思路：偷懒了 吧上体结果倒叙输出一遍，其实可以存在栈中 在输出  其实是一样的。
``` 
def levelOrder(self, root: TreeNode) -> List[List[int]]:
	if not root:return []
	res = []
	queue=[root]
	while queue:
		tmp =[]
		for _ in range(len(queue)):
			node = queue.pop(0)
			tmp.append(node.val)
			if node.left:
				queue.append(node.left)
			if node.right:
				queue.append(node.right)
		res.append(tmp)
	return res[::-1]
```

105. 从前序与中序遍历序列构造二叉树
	根据一棵树的前序遍历与中序遍历构造二叉树。
```
def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
	if not (inorder and preorder):return None
	root = TreeNode(preorder[0])
	idx = inorder.index(preorder[0])
	root.left = self.buildTree(preorder[1:idx+1],inorder[:idx])
	root.right = self.buildTree(preorder[idx+1:],inorder[idx+1:])
	return root
```

106. 从中序与后序遍历序列构造二叉树
	根据一棵树的中序遍历与后序遍历构造二叉树。
```
def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
	if not (inorder and postorder): return None
	root = TreeNode(postorder[-1])
	idx = inorder.index(postorder[-1])
	root.left = self.buildTree(inorder[:idx],postorder[:idx])
	root.right = self.buildTree(inorder[idx+1:],postorder[idx:-1])
	return root
```

108. 将有序数组转换为二叉搜索树
	给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
	高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
	思路：通过找中点构建平衡二叉搜索树
```
def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
	def buildtree(left,right):
		if left > right:
			return None
		mid = (left+right) // 2
		root = TreeNode(nums[mid])
		root.left = buildtree(left,mid-1)
		root.right = buildtree(mid+1,right)
		return root
	return buildtree(0,len(nums)-1)
```

109. 有序链表转换二叉搜索树
	给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
	本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
	思路：和上一题的区别在于这是链表，但是由于中序遍历刚好等于链表的顺序
	因此通过中序遍历将链表值一次插入节点即可。
```
def sortedListToBST(self, head: ListNode) -> TreeNode:
	def getLength(p):
		cont = 0
		while p:
			cont +=1
			p = p.next
		return cont
	def buildtree(left,right):
		if left > right:
			return None
		mid = (left + right) // 2
		root = TreeNode()
		root.left = buildtree(left,mid-1)
		nonlocal head
		root.val = head.val
		head = head.next
		root.right = buildtree(mid+1,right)
		return root
	length = getLength(head)
	return buildtree(0,length-1)
```


110. 平衡二叉树
	给定一个二叉树，判断它是否是高度平衡的二叉树。
	本题中，一棵高度平衡二叉树定义为：
```
def isBalanced(self, root: TreeNode) -> bool:
	if not root:return True
	def dfs(t):
		if not t:
			return 0
		return max(dfs(t.left),dfs(t.right))+1
	return True if abs(dfs(root.left)- dfs(root.right)) <= 1 and 
	self.isBalanced(root.left) and self.isBalanced(root.right) else False
```

111. 二叉树的最小深度
	给定一个二叉树，找出其最小深度。
	最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
	思路：层次遍历，找到的第一个叶子节点就是最小深度
```
def minDepth(self, root: TreeNode) -> int:
	if not root:return  0
	quee,mindept = [root],1
	while quee:
		for _ in range(len(quee)):
			node = quee.pop(0)
			if not node.left and not node.right:
				return mindept
			if node.left:
				quee.append(node.left)
			if node.right:
				quee.append(node.right)
		mindept +=1 
```

112. 路径总和
	给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
	叶子节点 是指没有子节点的节点。
	思路：就是递归不断的减去当前节点值，直到叶子节点值刚好等于最后剩下的值，表示存在总和等于目标值的
	路径，只要根节点的左右子树一个存在即可。
``` 
def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
	if not root: return False
	if not root.left and not root.right:
		return root.val == targetSum
	return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
```

113. 路径总和 II
	给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
	思路：根据递归的DFS当叶子节点满足条件将路径保存即可
```
def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
	res = []
	def dfs(root,target,tmp):
		if not root: return 
		if not root.left and not root.right:
			if root.val == target:
				res.append(tmp+[root.val])
		if root.left:
			dfs(root.left,target-root.val,tmp+[root.val])
		if root.right:
			dfs(root.right,target-root.val,tmp+[root.val])
	dfs(root,targetSum,[])
	return res
```

114. 二叉树展开为链表
	给你二叉树的根结点 root ，请你将它展开为一个单链表：
	展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
	展开后的单链表应该与二叉树 先序遍历 顺序相同。
	思路：对于任何一个节点，先获取左右子树展开，将左边先复制右子树，然后遍历右子树到末尾将原右子树展开的
	链接到后面。
```
def flatten(self, root: TreeNode) -> None:
	if not root:return None
	left = self.flatten(root.left)
	right = self.flatten(root.right)
	root.left = None
	root.right = left
	tail = root
	while tail.right:
		tail = tail.right
	tail.right = right
	return root
```

116. 填充每个节点的下一个右侧节点指针
	思路：这道题是为了将满二叉树横向连接，因此先需要依次遍历最左边节点，然后根据
	左节点，如果该节点存在左节点，将左节点的next连接到右节点，并且如果
	该节点后连接下一个节点，则将该节点的右节点的next连接到下一个节点的左节点上，循环即可、
```
 def connect(self, root: 'Node') -> 'Node':
        if not root:return None
        left = root
        while left.left:
            head = left
            while head:
                head.left.next = head.right

                if head.next:
                    head.right.next = head.next.left
                
                head = head.next
            left = left.left
        return root
```
117. 填充每个节点的下一个右侧节点指针 II
	这道题不同于上一道题在于这个数不是满二叉树，所以之前的方法不行。
	思路：这里其实可以直接用层次遍历，只需要单独进行一定修改，并且这个代码可以完全用于上一题。
```
def connect(self, root: 'Node') -> 'Node':
	if not root:return None
	queue = [root]
	while queue:
		for i in range(len(queue)-1):
			queue[i].next = queue[i+1]
		for _ in range(len(queue)):
			node = queue.pop(0)
			if node.left: queue.append(node.left)
			if node.right: queue.append(node.right)
	return root
```

118. 杨辉三角
给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
```
def generate(self, numRows: int) -> List[List[int]]:
	res = list()
	for i in range(numRows):
		tmp = list()
		for j in range(i+1):
			if j == 0 or i == j:
				tmp.append(1)
			else:
				tmp.append(res[i-1][j] + res[i-1][j-1] )
		res.append(tmp)
	return res

```

119. 杨辉三角 II
	给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。
	思路：和上一题思路相似，不过这里不需要计算所有层结果只需要记录最后一层结果
	所以用ans来记录上一层的结果，tmp用于计算当前层的结果。ans相当于子状态的存储。
```
def getRow(self, rowIndex: int) -> List[int]:
	ans=[]
	for i in range(rowIndex+1):
		tmp=[]
		for j in range(i+1):
			if j == 0 or i == j:
				tmp.append(1)
			else:
				tmp.append(ans[j]+ans[j-1])
		ans = tmp
	return ans
```

120. 三角形最小路径和
	给定一个三角形 triangle ，找出自顶向下的最小路径和。
	思路：这道题就是dp的思想，关键就是要自底向上的一个顺序。
```
def minimumTotal(self, triangle: List[List[int]]) -> int:
	for i in range(len(triangle)-2,-1,-1):
		for j in range(len(triangle[i])):
			triangle[i][j] +=min(triangle[i+1][j],triangle[i+1][j+1])
	return triangle[0][0]
```

121. 买卖股票的最佳时机
	只买一次，无代价。
	思路：每天有两个状态，拥有股票和没有股票，只需要不断更新这两个状态即可。最后
	返回的是没有股票的状态。
```
def maxProfit(self, prices: List[int]) -> int:
	nohave = 0
	have = -prices[0]
	for p in prices[1:]:
		nohave = max(nohave,have+p)
		have = max(have,-p)
	return nohave
```

122. 买卖股票的最佳时机 II
	多次买卖，无代价。
	思路：多次买入，所以有用股票最大化利益时考虑的是上一次拥有状态和买入当前股票
	中选择利益最大的情况。
```
def maxProfit(self, prices: List[int]) -> int:
	nohave = 0
	have = -prices[0]
	for p in prices[1:]:
		nohave = max(nohave,have+p)
		have = max(have,nohave-p)
	return nohave
```

123. 买卖股票的最佳时机 III
	只买两次，无代价。
	思路：其实就是给两次买入定义两个状态。
```
def maxProfit(self, prices: List[int]) -> int:
	dp_i_0_0 = 0
	dp_i_0_1 = -prices[0]
	dp_i_1_0 = 0
	dp_i_1_1 = -prices[0]
	for p in prices:
		dp_i_1_0 = max(dp_i_1_0,dp_i_1_1+p)
		dp_i_1_1 = max(dp_i_1_1,dp_i_0_0-p)
		dp_i_0_0 = max(dp_i_0_0,dp_i_0_1+p)
		dp_i_0_1 = max(dp_i_0_1,-p)
	return dp_i_1_0
```

309. 最佳买卖股票时机含冷冻期
	多次买卖，有冷冻期
	思路：因为多次买卖，所以have需要考虑nohave状态，但是由于这个有冷冻期，所以
	需要将当前状态存储prebuy
```
def maxProfit(self, prices: List[int]) -> int:
	nothave = 0
	have = -float('inf')
	prebuy = 0
	for p in prices:
		tmp = nothave
		nothave = max(nothave,have+p)
		have = max(have,prebuy-p)
		prebuy = tmp
	return nothave
```

714. 买卖股票的最佳时机含手续费
	多次买卖，有代价
	思路：和122相似，主要的区别在卖出时，除了加上收益还得减去代价fee
```
def maxProfit(self, prices: List[int], fee: int) -> int:
	nothave = 0
	have = -prices[0]
	for p in prices[1:]:
		nothave = max(nothave,have+p-fee)
		have = max(have,nothave-p)
	return nothave
```

901. 股票价格跨度
	这里需要做的是给一个股票价格，返回大于等于这个价格距离今天的个数 cont。
	思路：单调栈，降序，并且还存储cont
```
class StockSpanner:
def __init__(self):
	self.stack = []
def next(self, price: int) -> int:
	cont = 1
	while self.stack and self.stack[-1][0] <= price:
		cont += self.stack.pop()[1]
	self.stack.append((price,cont))
    return cont
```

125. 验证回文串
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
思路：双指针，遇到字母，相互比较，这里left<right 为了满足回文子串是奇数的状态。
```
def isPalindrome(self, s: str) -> bool:
	left,right = 0,len(s)-1
	while left < right:
		while left<len(s)-1 and not s[left].isalnum():
			left +=1
		while right>0 and not s[right].isalnum():
			right -=1
		if left < right:
			if s[left].lower() != s[right].lower():
				return False
			left +=1
			right -=1
	return True
```

128. 最长连续序列
	给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
	思路：用哈希表存储每个端点值对应连续区间的长度，若数已在哈希表中：跳过不做处理
	若是新数加入：取出其左右相邻数已有的连续区间长度 left 和 right；计算当前数的区间长度为：cur_length = left + right + 1
	根据 cur_length 更新最大长度 max_length 的值；更新区间两端点的长度值
```
def longestConsecutive(self, nums: List[int]) -> int:
	hash_dict = dict()
	max_length = 0
	for num in nums:
		if num not in hash_dict:
			left = hash_dict.get(num - 1, 0)
			right = hash_dict.get(num + 1, 0)
			cur_length = 1 + left + right
			if cur_length > max_length:
				max_length = cur_length
			hash_dict[num] = cur_length
			hash_dict[num - left] = cur_length
			hash_dict[num + right] = cur_length
	return max_length
```

129. 求根到叶子节点数字之和
	给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
	例如，从根到叶子节点路径 1->2->3 代表数字 123。
	计算从根到叶子节点生成的所有数字之和。
	思路：深度优先遍历，需要做的就是每次递归需要传入当前到父节点为止的值，并在找到
	叶子节点的时候将值加入的到最终结果里。
```
def sumNumbers(self, root: TreeNode) -> int:
	self.ans = 0
	def dfs(root,tmp):
		if not root :return 
		if not root.left and not root.right:
			self.ans +=(tmp*10 + root.val)
			return 
		dfs(root.left,tmp*10 + root.val)
		dfs(root.right,tmp*10 + root.val)
	dfs(root,0)
	return self.ans
```

130. 被围绕的区域
	给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。
	找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
	思路：反思路，先通过从周围的O开始，凡是连通的均用#占位表示都应该全为O，剩下的O
	表示被全部包围的O，剩下的就是遍历borad，将# 和O转化一下。
```
def solve(self, board: List[List[str]]) -> None:
	n,m = len(board),len(board[0])
	def dfs(x,y):
		if not 0<=x<n or not 0<=y<m or board[x][y] != "O":
			return 
		board[x][y] = "#"
		dfs(x+1,y)
		dfs(x-1,y)
		dfs(x,y+1)
		dfs(x,y-1)
	for i in range(n):
		dfs(i,0)
		dfs(i,m-1)
	for i in range(m):
		dfs(0,i)
		dfs(n-1,i)
	for i in range(n):
		for j in range(m):
			if board[i][j] == "O":
				board[i][j] = "X"
			elif board[i][j] == "#":
				board[i][j] = "O"
```

131. 分割回文串
	给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
	返回 s 所有可能的分割方案。
	思路：利用dp二维来存储从第i到j位置是都是回文子串，判断的标准就是如果
	s[i] == s[j] and dp[j+1][i-1]则为回文。当然如果i-j小于2，则不同判定第二个条件了。
	有了dp后，其实就是DFS了，判断idx到n的里面可以怎么划分回文子串。
	
```
def partition(self, s: str) -> List[List[str]]:
	n=len(s)
	dp = [[False]*n for _ in range(n)]
	for i in range(n):
		for j in range(i+1):
			if s[i] == s[j] and (i-j<=2 or dp[j+1][i-1]):
				dp[j][i] = True
	res = []
	def dfs(idx,tmp):
		if idx == n:
			res.append(tmp)
		for i in range(idx,n):
			if dp[idx][i]:
				dfs(i+1,tmp+[s[idx:i+1]])
	dfs(0,[])
	return res
```

133. 克隆图
	给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
	思路：这道题的主要思路是通过一个节点进行图的深度遍历，关键就是害怕节点被重复访问
	因此使用一个字典，key是原节点  vlaue为拷贝节点。将拷贝好的节点存到字典中
```
class Solution:
    def __init__(self):
        self.visited={}
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:return node
        if node in self.visited: return self.visited[node]

        cloneNode = Node(node.val,[])
        self.visited[node] = cloneNode
        if node.neighbors:
            cloneNode.neighbors = [self.cloneGraph(n) for n in node.neighbors]
        return cloneNode
```

134. 加油站
	我也没搞清楚
```
def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
	res = 0
	totle,curr = 0,0
	for i in range(len(gas)):
		curr += gas[i] - cost[i]
		totle += gas[i] - cost[i]
		if curr < 0:
			res = i + 1
			curr = 0
	return -1 if totle < 0 else res
```

136. 只出现一次的数字
	给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
	思路：异或的思想
```
def singleNumber(self, nums: List[int]) -> int:
	res = 0
	for n in nums:
		res ^=n
	return res
```

139. 单词拆分
给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
```
def wordBreak(self, s: str, wordDict: List[str]) -> bool:
	dp = [False] * (len(s)+1)
	dp[0] = True
	for i in range(1,(len(s)+1)):
		for j in range(0,i):
			if dp[j] and (s[j:i] in wordDict):
				dp[i]=True
				break         
	return dp[-1]
```

141. 环形链表
	思路：快慢指针的问题，如果快慢指针重合，表示有环。
```
def hasCycle(self, head: ListNode) -> bool:
	if not head or not head.next or not head.next.next:return False
	fast = slow = head
	while fast.next and fast.next.next:
		fast = fast.next.next
		slow = slow.next
		if fast == slow:
			return True
	return False
```

142. 环形链表 II
	找到环形入口。思路：先找到重合点，然后将fast指向头指针，然后同时移动slow和fast
	直到两个指针在重合，则为环形的入口节点
```
def detectCycle(self, head: ListNode) -> ListNode:
	if not head:
		return head
	fast = slow = head
	while fast.next and fast.next.next:
		slow = slow.next
		fast = fast.next.next
		if slow == fast:
			break
	if fast.next and fast.next.next:
		fast = head
		while True:
			if slow == fast:
				return fast
			fast = fast.next
			slow = slow.next
	else:
		return None
```