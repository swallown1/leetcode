## 每日一题 - 121. 买卖股票的最佳时机

### 信息卡片

- 时间：2020-12-12
- 题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
- tag：`动态规划`
- 难度：困难


### 题目描述

```
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

示例 2：

输入：s = "a", t = "a"
输出："a"

```

### 参考答案

### 动态规划

针对股票问题一套通用的解法就是使用动态规划的问题，根据labuladong的文章，直接使用他的DP状态来做就可以了。

dp[n][2]则是存储的状态，表示第n天的两种状态下的最大收益。

dp[i][0] 表示第i天手里没有股票
dp[i][1] 表示第i天手里有股票

有了子状态的存储了，那就是状态转移了。

dp[i][0] = max(dp[i-1][0],dp[i-1][1]+price[i])
这里的含义指的是，第i天如果没有股票，是根据两种可能得到的。
第一种是前一天没有股票的状态进行保持，另一种是前一天有股票，今天卖了，因此加上了price[i]

dp[i][1] = max(dp[i-1][1],dp[i-1][0]-price[i])
这里的含义指的是，第i天如果有股票，是根据两种可能得到的。
第一种是前一天有股票的状态进行保持，另一种是前一天没有股票，今天买进了，因此减去price[i]

因为这里只有一次操作，因此dp[i-1][0]必然都是0，因此可以化简
dp[i][1] = max(dp[i-1][1],-price[i])

还有一个问题就是初始话问题了，对于dp[0][1]、dp[0][0]进行初始话设置
 dp[0][1]表示第一天买进，这当前的利润当然是-prices[0]了
 dp[0][0]表示第一天不动，这当前的利润当然是0了

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not len(prices):return 0
        n=len(prices)
        dp = [[0,0] for _ in range(n)]
        for p in range(n):
            if p == 0:
                dp[p][0] = 0
                dp[p][1] = -prices[p]
            else:    
                dp[p][0] = max(dp[p-1][0],dp[p-1][1]+prices[p])
                dp[p][1] = max(dp[p-1][1],-prices[p])
        return dp[n-1][0] 
        
```

**优化：**

因为只需要前面一次的子状态的结果，因此只需要两个变量

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        notbuy = 0
        buy = -int(1e6)
        for p in range(len(prices)):
            notbuy = max(notbuy,buy+prices[p])
            buy = max(buy,-prices[p])
        return notbuy
```

### 其他优秀解答

```
暂无
```
 