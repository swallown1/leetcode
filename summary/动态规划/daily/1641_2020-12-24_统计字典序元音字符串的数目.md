## 每日一题 - 1641. 统计字典序元音字符串的数目

### 信息卡片

- 时间：2020-12-24
- 题目链接：https://leetcode-cn.com/problems/count-sorted-vowel-strings/
- tag：`动态规划`
- 难度：中等

### 题目描述

```
给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。

字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。

 

示例 1：

输入：n = 1
输出：5
解释：仅由元音组成的 5 个字典序字符串为 ["a","e","i","o","u"]
示例 2：

输入：n = 2
输出：15
解释：仅由元音组成的 15 个字典序字符串为
["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"]
注意，"ea" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后
示例 3：

输入：n = 33
输出：66045

```

### 参考答案

**题意理解：**


#### 动态规划

本题右移个地方需要注意，比如当n=3时，以u结尾的字符串个数等于 
n=2时以 a,e,i,o,u结尾的字符串的总和。因为只需要在这些子串后面加u即可。
也就是说对于dp[n][u] = dp[n][a]+dp[n][e]+dp[n][i]+dp[n][o]+dp[n][u].

动态规划几步走：

1、找状态：这里的状态有n以及不同字母结尾的子串

2、找子问题：子问题就是记录长度为n且以某元音字符c结尾的子串个数

3、找状态转移：此时的状态转移方程为：
	dp[n][u] = dp[n][a]+dp[n][e]+dp[n][i]+dp[n][o]+dp[n][u].
	
4、初始状态：对于n=1时，无论以什么字母结尾的子串个数为1


```
class Solution:
    def countVowelStrings(self, n: int) -> int:
        dp = [[0]*5 for _ in range(n+1)]
        for i in range(5):
            dp[1][i] = 1
        for i in range(2,n+1):
            for j in range(5):
                dp[i][j] = sum(dp[i-1][:j+1])
        return sum(dp[-1][:])

```

通过上面看到第n的状态只和n-1的状态相关，因此可以优化空间，将二维数组
优化成一维数组。

```
class Solution:
    def countVowelStrings(self, n: int) -> int:
        dp = [1,1,1,1,1]
        for i in range(2,n+1):
            for j in range(4,0,-1):
                dp[j] = sum(dp[:j+1])
        return sum(dp)
```

这里说一下为什么要后往前优化，是因为如果从前往后。
当n=3时，考虑以i结尾时，需要求和以a，e结尾的个数，此时存的是n=2的状态。
但是之前在考虑以a，e结尾时候，已经改成n=3的状态，所以会出现问题。

反过来，由于考虑以e结尾时，不会计算以i结尾的个数，因此从后往前不会出错。

### 其他优秀解答

```
暂无
```



